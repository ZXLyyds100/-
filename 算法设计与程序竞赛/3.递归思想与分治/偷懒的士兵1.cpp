18442 不被选中巡逻的士兵最小编号
时间限制:1000MS  代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题   语言: G++;GCC;VC

Description
有N个士兵站成一队列, 现在需要选择几个士兵派去侦察。
为了选择合适的士兵, 多次进行如下操作: 如果队列超过三个士兵, 那么去除掉所有站立位置为奇数的士兵, 
或者是去除掉所有站立位置为偶数的士兵。直到不超过三个战士，他们将被送去侦察。现有一个“聪明”的士兵，
经常通过选择站在合适的初始位置，成功避免被选中去侦察。这引起了陈教官的注意。陈教官希望你编写一个程序，
当给定士兵数之后，输出不可能被选中去巡逻的最少编号位置（如果不存在不可能被选中的位置，则输出0）。

注: 按上法得到少于三士兵的情况不用去巡逻。

1 <= N <= 100000



输入格式
有多行（不多于20行），每行一个数字N，最后一行是0


输出格式
对每一行的数字N，不可能被选中去巡逻的最小位置

直到没有数字


输入样例
9
6
0


输出样例
2
0



  这次问题和前面很类似，只不过是问题改为了不被叫去巡逻的最小编号

  #include<iostream>
#include<algorithm>
using namespace std;
int a[100010];
int dfs(int n, int s, int step) {//n是当前人数，s是当前第一位士兵的最原本的位置，也就是一开始的距离，step就是间隔距离
	if (n == 3) {
		return 99999;
	}
	else if (n < 3) {
		return s;
	}
	else {
		return min(dfs((n + 1) / 2, s, step * 2), dfs(n / 2, s + step, step * 2));
	}
}
怕理解不了这个抽象的例子，这里给个小例子
函数返回值是最小的不被叫去巡逻的位置
那么min(dfs((n + 1) / 2, s, step * 2), dfs(n / 2, s + step, step * 2));
就是去奇数和去偶数的俩种情况
就好像9去奇数就剩5个，6去奇数剩下3个
然后俩个数之间的编号距离变为俩倍
去偶数那么第一个数就是当前数加上2*step
int main() {
	int n;
	while (cin >> n && n) {
		int ans = dfs(n, 1, 1);
		if (ans == 99999) {
			cout << 0 << endl;
		}
		else {
			cout << ans << endl;
		}
	}
	return 0;
}
