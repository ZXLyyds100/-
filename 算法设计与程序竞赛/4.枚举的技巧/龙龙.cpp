
//
//8623 龙龙
//该题有题解
//
//时间限制 : 1000MS  代码长度限制 : 10KB
//提交次数 : 664 通过次数 : 118
//
//题型 : 编程题   语言 : G++; GCC
//
//Description
//在比赛的时候，1Y(1 次AC)是很值得高兴的事情。但很多大牛总会因为很弱智的错误先WA 一次，再AC。
//而很多时候，这点罚时的差距使得他们与金牌无缘。弱智错误系列中最显著的就是忘记加龙龙。
//
//龙龙外国人叫它作long long，表示64位整数，输入与输出64位整数则可以使用例如
//scanf("%lld", &a)与printf("%lld", a)的形式完成。很多图论和动态规划的题目中，
//虽然题目说最后输出的答案是32 位的整数，但中间计算的过程有时会超过int，这时我们就要使用龙龙了。
//
//可惜的是，很多同学刚开始学写程序都是用VC的，在VC上是无法使用long long的，我们要用__int64
//代替，输入与输出64位整数则可以使用例如scanf("%I64d", &a)与printf("%I64d", a)的形式完成。
//
//
//但是提交上OJ 的时候，如果使用GCC或G++，都只支持long long，我们在提交时又得按照上边的改回来（的确挺麻烦, 窘）。
//为了让知道龙龙的同学们记得使用龙龙，不知道的学习使用龙龙，下边有个很简单的函数，希望大家
//求出它的返回值：
//
//long long H(int n) {
//	long long res = 0;
//	int i;
//	for (i = 1; i <= n; i = i + 1) {
//		res = (res + n / i);
//	}
//	return res;
//}
//
//不过直接使用这个函数是会超时的，必须改造这个函数，当然这一定难不到未来的编程高手--你
//
//
//
//输入格式
//第一行是数字T(T <= 1021)表示case数，接下来T 行，每行一个整数n，n是一个32 位整数（保证可以由int 表示）。
//
//
//输出格式
//函数返回值。
//
//
//输入样例
//2
//5
//10
//
//
//输出样例
//10
//27

//通过观察会发现，i的取值在（n/2,n]时都为1，在(n/3，n/2]时都为2，以此类推，会发现，i在不同区间的取值是有规律的，且得出的n/i为以1为开头差为1的等差数列
#include<iostream>
#include<algorithm>
using namespace std;
int main() {
	int t;
	cin >> t;
	while (t--) {
		long long n;
		cin >> n;
		long long res = 0;
		int i, end, st;
		for ( i = 1, st = n / 2, end = n; st < end; i++) {
			st = n / (i + 1);
			end = n / i;
			res += i * (end - st);//区间有多少个n/i再去乘n/i，一直循环知道end==st
		}
		for (int i = end; i >= 1; i--)res += n / i;//然后计算剩下的
		cout << res << endl;
	}
	return 0;
}
